In this implementation, the game board is represented as a 2D array such that rows 1-6 in the array correspond to rows 6-1 on the board and columns 1-6 correspond to columns A-G on the board. Upon execution, the program runs smoothly and quickly without errors, provided the user does not enter a non-number as their player number (unfortunately I couldn't find a way to fix that). The main driving method for determining both the win condition and where the AI chooses to place its next piece is the connected() method. This method will return the maximum number of a certain piece being lined up as a result of it being placed in a certain position on the board. For example, if there is a line of 3 X's at D1, E1, and F1, connected() will return 4 as a result of an X being placed at G1. If, after a piece is placed, the corresponding connected() call returns at least 4, the game ends. Otherwise, it ends after 42 turns, the maximum possible on a 6*7 board. When the AI chooses a column, it looks at each of the possible resulting connections when either its piece or the player's piece is placed in each column, and uses that information to attempt to either build its own connections or block the player's, depending on which takes precedent. If any of these resulting connections are 4 or higher, that corresponds to it either making or blocking a winning move. It checks columns in order from the center outwards, meaning it also follows basic heuristic strategy (including placing its piece in the bottom center square on the first turn).

Video demonstration link: https://youtu.be/tvbkx649kBM